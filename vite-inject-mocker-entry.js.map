{"version":3,"mappings":";;;84DAIO,MAAMA,EAAwB,CAEnC,MAAQ,IAAIC,GAEZ,aAAc,CAAC,CAQf,MAAM,SAASC,EAAQ,CACrB,KAAK,MAAM,IAAIA,CAAM,CACvB,CAEA,MAAM,OAAOC,EAAK,CAChB,KAAK,MAAM,OAAOA,CAAG,CACvB,CAEA,MAAM,YAAa,CACjB,KAAK,MAAM,MAAK,CAClB,CACF,CAGA,MAAMC,GAAOC,GAAW,CACtB,OAAQA,EAAM,CACZ,IAAK,YACH,OAAO,QAAQ,QAAQ,CACrB,GAAI,GACJ,IAAK,GACL,UAAW,EACnB,CAAO,EACH,IAAK,cACH,OAAO,QAAQ,QAAQ,CACrB,SAAU,QACV,WAAY,GACZ,YAAa,GACb,YAAa,GACb,aAAc,EACtB,CAAO,EACH,IAAK,aACH,OAAO,QAAQ,QAAO,CAC5B,CACA,EAIA,MAAMC,WAA0BC,EAAa,CAC3C,WAAY,CAEZ,CACF,CAEA,SAASC,GAAqBC,EAAa,CACzC,MAAMC,EAAS,IAAIJ,GACjBG,EAAY,mBAAmB,EAC/B,CACE,UAAUE,EAAIC,EAAU,CACtB,OAAOR,GAAI,WAA6B,CAC1C,EACA,YAAYO,EAAIC,EAAUC,EAAS,CACjC,OAAOT,GAAI,aAAwC,CACrD,EACA,MAAM,WAAWU,EAAK,CACpB,OAAOV,GAAI,YAAqB,CAClC,CACN,EACI,IAAIW,IACK,WAAW,0BAA0B,MAAM,GAAGA,CAAI,EAE3D,CACE,KAAM,EACZ,CACA,EAEE,kBAAW,kBAAuBL,EAE3BM,GAAoB,CACzB,cAAe,mBACnB,CAAG,CACH,CAEA,WAAW,qBAAuBR,GAAqB,IAAM,IAAIR,EAAyB","names":["ModuleMockerInterceptor","MockerRegistry","module","url","rpc","method","BuildModuleMocker","ModuleMocker","registerModuleMocker","interceptor","mocker","id","importer","options","ids","args","createCompilerHints"],"ignoreList":[0],"sources":["../node_modules/.pnpm/storybook@10.1.10_@testing-library+dom@10.4.0_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/storybook/assets/server/mocker-runtime.template.js"],"sourcesContent":["import { MockerRegistry } from '@vitest/mocker';\nimport { ModuleMocker, createCompilerHints } from '@vitest/mocker/browser';\n\n/** An interceptor for module mocking. */\nexport class ModuleMockerInterceptor {\n  // A registry for runtime mocks (e.g., `sb.mock('path', () => ({}))`)\n  mocks = new MockerRegistry();\n\n  constructor() {}\n\n  /**\n   * Called by ModuleMocker when `sb.mock()` is executed. We just store the mock in our registry.\n   * The dynamic MSW handler will pick it up on the next relevant network request. Currently, we\n   * don't use this.mocks in any way. Mocks will be registered in the user's preview file and live\n   * until the end. There is no way to invalidate or delete them.\n   */\n  async register(module) {\n    this.mocks.add(module);\n  }\n\n  async delete(url) {\n    this.mocks.delete(url);\n  }\n\n  async invalidate() {\n    this.mocks.clear();\n  }\n}\n\n// Dummy implementation of the RPC interface, since it is not used in build mode.\nconst rpc = (method) => {\n  switch (method) {\n    case 'resolveId':\n      return Promise.resolve({\n        id: '',\n        url: '',\n        optimized: false,\n      });\n    case 'resolveMock':\n      return Promise.resolve({\n        mockType: 'dummy',\n        resolvedId: '',\n        resolvedUrl: '',\n        redirectUrl: '',\n        needsInterop: false,\n      });\n    case 'invalidate':\n      return Promise.resolve();\n  }\n};\n\n// In build mode, we don't need runtime handling of mocks.\n// Everything is handled at build time and via the MSW interceptor.\nclass BuildModuleMocker extends ModuleMocker {\n  queueMock() {\n    // noop\n  }\n}\n\nfunction registerModuleMocker(interceptor) {\n  const mocker = new BuildModuleMocker(\n    interceptor('__vitest_mocker__'),\n    {\n      resolveId(id, importer) {\n        return rpc('resolveId', { id, importer });\n      },\n      resolveMock(id, importer, options) {\n        return rpc('resolveMock', { id, importer, options });\n      },\n      async invalidate(ids) {\n        return rpc('invalidate', { ids });\n      },\n    },\n    (...args) => {\n      return globalThis.__STORYBOOK_MODULE_TEST__.spyOn(...args);\n    },\n    {\n      root: '',\n    }\n  );\n\n  globalThis['__vitest_mocker__'] = mocker;\n\n  return createCompilerHints({\n    globalThisKey: '__vitest_mocker__',\n  });\n}\n\nglobalThis.__STORYBOOK_MOCKER__ = registerModuleMocker(() => new ModuleMockerInterceptor());\n"],"file":"vite-inject-mocker-entry.js"}